import * as Data from "./Data.js";
import * as DataLink from "./DataLink.js";
import * as Chart from "./charts.js";

// re-export DataLink
export {DataLink};

// This file contains a few classes for plotting time-series data using cubism strip charts

// There are three available classes used for managing cubism:
// CubismController: manages a list of strip charts using a
//                   configuration provided by the "DataConfig" API in
//                   the Flask backend. This class plots a list of
//                   time-series corresponding to a list of instances for a
//                   single group
// CubismMultiMetricController: manages a list of strip charts using a
//                              configuration procided by the
//                              "DataConfig" API in the Flask backend.
//                              This class plots a list of time-series
//                              corresponding to a list of metrics for a
//                              single instance in a single group. 
// CubismSingleStreamController: manages a single strip chart with a
//                               single time-series as input. Does not
//                               use the "DataConfig" API.

// Each of these classes manages a D3DataBuffer object to get data and
// displays a number of strip charts to visualize the data. Each class
// also manages interfaces with the webpage UI for specifying the format
// of the plots to be shown.


// To set up each class, call the contructor, then connect a number UI
// components (using the various "xxxController" functions), then call
// run()

// Internal class used by the CubismController and
// CubismMultiMetricController classes for managing the DataConfig
// "config" object
class TimeSeries {
  // config: DataConfig object generated by the redis backend and
  //         encoded as a JSON dictionary. Should contain the following
  //         fields:
  //           group: name of this group
  //           metric_list: list of all the metrics in this group
  //           instances: list of all the instances in this group
  //           streams: list of stream associated with this group
  //           stream_links: list of links to access each stream
  //           metric_config: configuration for display of each metric
  // href: (optional) function which will be passed the data_config group and
  //        instance corresponding to the clicked time-series and should 
  //        return a URL string that the user will navigate to. If
  //        nothing is passed, then nothing will happen when the user
  //        clicks on a strip chart
  constructor(config, href) {
    this.config = config;
    this.href = href;

    this.server_delay = 5000; // guess, for now
  }

  // Get the "DataLink" object to be used to query data for a list of
  // time-series
  // stream_index: The index into the streams/stream_links list for the
  //               stream corresponding to the DataLink we want
  // metric_list: The list of metric names to be queried in the
  //              time-series list
  // instance_list: The list of instances to be queried in the time-series
  //             list
  // NOTE: The final list of time-series will be a product of the
  // metric_list and the instance_list. I.e. if len(metric_list) = 3 and
  // len(instance_list) = 5 then there will be 15 total time-series
  // generated
  data_link(stream_index, metric_list, instance_list) {
    if (metric_list === undefined) {
      metric_list = this.config.metric_list;
    }
    if (instance_list === undefined) {
      var instances = this.config.instances;
    }
    else {
      var instances = [];
      for (var i = 0; i < instance_list.length; i++) {
        instances.push( this.config.instances[instance_list[i]] );
      }
    }
    return new DataLink.MetricStreamLink($SCRIPT_ROOT + this.config.stream_links[stream_index], this.config.streams[stream_index], 
        this.config.group, instances, metric_list, false);
  }

  // Get the time step value corresponding to a certain stream
  // stream_index: the index into the streams/stream_links list of the
  //               `stream to be inspected.
  // callback: Callback function to be called after the time-step value  
  //           is retreived. This function will be passed one argument: 
  //           the time step in milliseconds.
  infer_step(stream_index, callback) {
    if (this.config.stream_links.length == 0) return callback(0);
 
    var link = new DataLink.MetricStreamLink($SCRIPT_ROOT + this.config.stream_links[stream_index], this.config.streams[stream_index],
        this.config.group, this.config.instances, this.config.metric_list, false);

    return d3.json(link.step_link(), function(data) { callback(data.step); });
  }

  // collect default parameters from metric
  default_param(metric) {
    return this.config.metric_config[metric];
  }

  // Internal function: hooks up the defined href to cubism for when the
  // user clicks on a strip chart 
  getLink(index) {
    if (!(this.href === undefined)) {
        return this.href(this.config.group, this.config.instances[index]);
    }
    return undefined;
  }
}

export class PlotlySingleStreamController {
  constructor(target, link) {
    this.link = link;
    this.target = target;
    this.max_data = 1000;
    // setup layout
    this.layout = {
      title: link.name()
    };
    // make a new plotly scatter plot
    this.scatter = new Chart.TimeSeriesScatter(target, this.layout);
  }

  getTimeStep(callback) {
    var self = this;
    d3.json(this.link.step_link(), function(data) {
        self.step = data.step;
        callback(self);
    });
  }

  // get the timestep and then start
  run() {
    this.getTimeStep(function(self) {
      self.updateData();
    });
  }

  updateData() {
    // make a new buffer
    // to be on the safe side, get back to ~1000 data points
    var start = new Date(); 
    start.setSeconds(start.getSeconds() - this.step * this.max_data / 1000); // ms -> s

    var data = new Data.D3DataLink(this.link);
    // get the poll
    var poll = new Data.D3DataPoll(data, this.step, []);

    // get the data source
    //var source = new Data.D3DataSource(this.link, -1);

    // wrap with a buffer
    this.buffer = new Data.D3DataBuffer(poll, this.max_data, [this.scatter.updateData.bind(this.scatter)]);
    this.buffer.start(start);
  }

  getData(start, stop) {
    this.buffer.stop();
    this.buffer.getData(start, stop);
  }

  timeRangeController(id_start, id_end, id_toggle) {
    var self = this;
    $(id_toggle).on("date-change", function() {
      var toggle_val = $(id_toggle).val();
      if (toggle_val == "live") {
        if (!self.buffer.isRunning()) {
          var start = new Date(); 
          start.setSeconds(start.getSeconds() - self.step * self.max_data / 1000); // ms -> s
          self.buffer.start(start);
        }
      }
      else if (toggle_val == "lookback") {
        if (self.buffer.isRunning()) {
          self.buffer.stop();
        }
        var start = $(id_start).datetimepicker('getValue');
        var end = $(id_end).datetimepicker('getValue');
        self.buffer.getData(start, end);
      }
    });
    return this;
  }
}

// Controller for connecting cubism plots with a single time-series
export class CubismSingleStreamController {
  // target: the div-id (including the '#') where the cubism plots will
  //         be drawn
  // link: a DataLink object to be used to get data. The name() of the
  //       DataLink object will also be used for display.
  // height: the height of the cubism time strip plot to be drawn
  constructor(target, link, height) {
    this.link = link;
    this.target = target;
    this.height = height;
    this.max_data = 1000;

    this.range = [];
  }

  // Internal function: get the time step and build the cubism context 
  buildContext(callback) {
    var self = this;
    // get the link
    d3.json(this.link.step_link(), function(data) {
      create_cubism_context_with_step(self.target, data.step, function(step, context) {
        self.step = data.step;
        self.context = context;
        callback(self);
      });
    });
  }

  // Connect the cubism plot height to a HTML form field 
  // id: the jQuery specified of the HTML form field
  heightController(id) {
    var self = this;
    $(id).change(function() { self.updateParam(this.value, "height"); });
    return this;
  }

  // Connect the range lo/hi of each plot to a pair of HTML form fields
  // id_lo: the jQuery specified of the HTML form field controlling the
  //        range minimum value
  // id_hi: the jQuery specified of the HTML form field controlling the
  //        range maximum value
  // update_on_metric_change: (optional) set to true to update the 
  //                          HTML form field value to the default
  //                          metric configuration on metric name
  //                          change. True by default. If set to false,
  //                          then this class will never write to the
  //                          specified HTML form field.
  rangeController(id_lo, id_hi, update_on_metric_change) {
    var self = this;

    $(id_lo).keypress(function(e) {
      if (e.which == 13) {
        self.updateParam(this.value, "range-lo");
      }
    });
    $(id_hi).keypress(function(e) {
      if (e.which == 13) {
        self.updateParam(this.value, "range-hi");
      }
    });

    if (!(update_on_metric_change === false)) {
        this.range_lo_controller = id_lo;
        this.range_hi_controller = id_hi;
    }
    return this;
  }

  // Internal function: update a display parameter of the cubism charts
  updateParam(input, param_name) {
    // update this param
    if (param_name == "height") this.height = input;
    else if (param_name == "range-hi") this.range[1] = input;
    else if (param_name == "range-lo") this.range[0] = input;
    // if no valid update, just return
    else return;

    // redraw horizons
    var data = d3.select(this.target).selectAll('.horizon').data();
    delete_horizons(this);
    make_horizons(this, data);
  }

  // Internal function: start of the D3DataBuffer and collect data
  updateData() {
    // make a new buffer
    // to be on the safe side, get back to ~1000 data points
    var start = new Date(); 
    start.setSeconds(start.getSeconds() - this.step * this.max_data / 1000); // ms -> s
    this.cubism_on = false;

    var data = new Data.D3DataLink(this.link);
    // get the poll
    var poll = new Data.D3DataPoll(data, this.step, []);

    // get the data source
    //var source = new Data.D3DataSource(this.link, -1);

    // wrap with a buffer
    this.buffer = new Data.D3DataBuffer(poll, this.max_data, [this.startCubism.bind(this)]);
    this.cubism_on = false;
    this.buffer.start(start);
  }

  // Internal function: build the function to link data between the D3DataBuffer and cubism
  // 
  // NOTE: cubism polls the returned function for data, so we can't run
  //       the cubism data conversion as a listener function to the
  //       D3DataBuffer. Instead, we give the buffer directly to cubism
  //       and let it access the buffer whenever. This requires the
  //       buffer to be in a valid state at all times. Since Javascript
  //       execution is single threaded, we really just need the buffer
  //       to be valid in between individual poll's to the backend for
  //       data. The D3DataBuffer class does guarantee this.
  dataLink(buffers) {
    return build_data_link(0, buffers[0]);
  }

  // Internal function: run cubism for the first time
  startCubism(buffers) {
    if (!this.cubism_on) {
      var metrics = [this.context.metric(this.dataLink(buffers), this.link.name())];
      make_horizons(this, metrics);
      this.cubism_on = true;
    }
  }

  // Start running the cubism context
  run() {
    this.buildContext(function(self) {
      self.updateData();
    });
  }

}

export class CubismMultiMetricController {
  // target: the div-id (including the '#') where the cubism plots will
  //         be drawn
  // NOTE: the following 3 parameters are passed directly to the TimeSeries class
  // timeseries_config: DataConfig object for "TimeSeries" -- see
  //                    constructor
  // instance_index: The index into the list of instances in
  //              "timeseries_config" corresponding to the instance we
  //              wanted plotted in each time-series
  // height: the height of the cubism time strip plot to be drawn
  constructor(target, timeseries_config, instance_index, stream_index, height) {
    this.timeseries = new TimeSeries(timeseries_config);
    this.target = target;
    this.height = height;
    this.instance_index = instance_index;
    this.stream_index = stream_index;

    this.max_data = 1000;
  }

  // Internal function: get the time step and build the cubism context 
  buildContext(callback) {
    var self = this;
    create_cubism_context(this.target, this.timeseries, function(step, context) {
      self.step = step;
      self.context = context;
      callback(self);
    });
  }

  // Connect the cubism plot height to a HTML form field 
  // id: the jQuery specified of the HTML form field
  heightController(id) {
    var self = this;
    $(id).change(function() { self.updateHeight(this.value); });
    return this;
  }


  // Connect the time-series stream name to a HTML form field 
  // id: the jQuery specified of the HTML form field
  streamController(id) {
    var self = this;
    $(id).change(function() {self.updateStream(this.value);});
    return this;
  }
  
  // Internal function: change the stream name of the time-series
  // plotted in cubism 
  updateStream(input) {
    this.stream_index = input;
    var self = this;
    this.timeseries.infer_step(input, function(step) {
      self.step = step;
      self.context.step(step);
      // remake the data
      self.updateData(true);
    });
  }

  // Internal function: change the height of the cubism plots
  updateHeight(input) {
    this.height = input;

    // redraw horizons
    var data = d3.select(this.target).selectAll('.horizon').data();
    delete_horizons(this);
    make_horizons(this, data);

  }
 
  // Internal function: start of the D3DataBuffer and collect data
  // remove_old: whether to delete the existing cubism plots
  updateData(remove_old) {
    // if no streams, don't do anything
    if (this.timeseries.config.streams.length == 0) {
      return;
    }

    if (remove_old === true)
      delete_horizons(this);

    if (!(this.buffer === undefined)) {
      this.buffer.stop();
    }

    // make a new buffer
    var start = new Date();
    start.setSeconds(start.getSeconds() - this.step * this.max_data / 1000); // ms -> s
    this.cubism_on = false;

    // get the link
    var poll = new Data.D3DataPoll(new Data.D3DataLink(this.timeseries.data_link(this.stream_index, undefined, [this.instance_index])),
      this.step);
    // and the buffer
    this.buffer = new Data.D3DataBuffer(poll, this.max_data, [this.startCubism.bind(this)]);
    this.buffer.start(start);
  }

  // Internal function: build the functions to link data between the D3DataBuffer and cubism
  dataLinks(buffers) {
    var ret = [];
    for (var j = 0; j < this.timeseries.config.metric_list.length; j++) {
      ret.push( build_data_link(j, buffers[j]) );
    }
    return ret;
  }

  // Internal function: run cubism for the first time
  startCubism(buffers) {
    if (!this.cubism_on) {
      this.cubism_metrics = add_metrics(this, this.dataLinks(buffers), false);
      this.cubism_on = true;
    }
  }

  // Start running cubism
  run() {
    this.buildContext(function(self) {
      self.updateData();
    });
  }

}

// class for controlling parameters of cubism context
export class CubismController {
  // target: the div-id (including the '#') where the cubism plots will
  //         be drawn
  // NOTE: the following 3 parameters are passed directly to the TimeSeries class
  // timeseries_config: DataConfig object for "TimeSeries" -- see
  //                    constructor
  // metric: the name of the metric to be shown in each time-series 
  // height: the height of the cubism time strip plot to be drawn
  constructor(target, timeseries_config, metric, stream_index, height) {
    this.timeseries = new TimeSeries(timeseries_config);

    this.height = height;
    this.metric = metric;
    this.target = target;
    this.stream_index = stream_index;

    this.range = [];

    // max data
    this.max_data = 1000;
  }

  // Internal function: get the time step and build the cubism context 
  buildContext(callback) {
    var self = this;
    create_cubism_context(this.target, this.timeseries, function(step, context) {
      self.step = step;
      self.context = context;
      callback(self);
    });
  }

  // Internal function: set the default configuration for the plot
  // display based on the input metric
  set() {
    this.metricParam();
    return this;
  }

  // Specify a function to change the URL when the user clicks on a
  // strip chart
  // Fhref: function which will be passed the data_config group and
  //        instance corresponding to the clicked time-series and should 
  //        return a URL string that the user will navigate to.
  linkFunction(Fhref) {
    this.timeseries.href = Fhref;
    return this;
  }
 
  // Connect the time-series metric name to a HTML form field 
  // id: the jQuery specified of the HTML form field
  metricController(id) {
    var self = this;
    $(id).change(function() { self.updateMetric(this.value); });
    return this;
  }

  // Connect the strip chart height to a HTML form field
  // id: the jQuery specified of the HTML form field
  heightController(id) {
    var self = this;
    $(id).change(function() { self.updateParam(this.value, "height"); });
    return this;
  }
 
  // Connect the range lo/hi of each plot to a pair of HTML form fields
  // id_lo: the jQuery specified of the HTML form field controlling the
  //        range minimum value
  // id_hi: the jQuery specified of the HTML form field controlling the
  //        range maximum value
  // update_on_metric_change: (optional) set to true to update the 
  //                          HTML form field value to the default
  //                          metric configuration on metric name
  //                          change. True by default. If set to false,
  //                          then this class will never write to the
  //                          specified HTML form field.
  rangeController(id_lo, id_hi, update_on_metric_change) {
    var self = this;

    $(id_lo).keypress(function(e) {
      if (e.which == 13) {
        self.updateParam(this.value, "range-lo");
      }
    });
    $(id_hi).keypress(function(e) {
      if (e.which == 13) {
        self.updateParam(this.value, "range-hi");
      }
    });

    if (!(update_on_metric_change === false)) {
        this.range_lo_controller = id_lo;
        this.range_hi_controller = id_hi;
    }
    return this;
  }

  // Connect the time-series stream name to a HTML form field 
  // id: the jQuery specified of the HTML form field
  streamController(id) {
    var self = this;
    $(id).change(function() {self.updateStream(this.value);});
    return this;
  }

  // Internal function: hook up cubism with the link function
  onClick(stream_name, index) {
    // check if link function is defined
    var link = this.timeseries.getLink(index);
    if (!(link === undefined)) {
        // go there
        window.location.href = $SCRIPT_ROOT + "/" + link;
    }
  }

  // Internal function: set the configuration of the plots to be
  // displayed from the default configuration of the specified metric
  // (if such configuration exists)
  metricParam() {
    var metric_param = this.timeseries.default_param(this.metric);
    if (metric_param === undefined) {
      metric_param = {};
    }
    if (!(metric_param.range === undefined)) {
      this.range = metric_param.range; 
    }
    else {
      this.range = [];
    }

    this.format = metric_param.format;
    // set in range values
    if (!(this.range_lo_controller === undefined)) {
      if (this.range.length != 0) {
        $(this.range_lo_controller).val(this.range[0]);
      }
      else { 
       $(this.range_lo_controller).val("");
     }
    } 
    if (!(this.range_hi_controller === undefined)) {
      if (this.range.length != 0) {
        $(this.range_hi_controller).val(this.range[1]);
      }
      else {
        $(this.range_hi_controller).val("");
      }
    }
  }

  // Internal function: change the metric name being shown in the cubism charts
  updateMetric(metric) {
    this.metric = metric;
    this.metricParam();
    this.updateData(true);
  } 

  // Internal function: change the stream name of the time-series
  // plotted in cubism 
  updateStream(input) {
    this.stream_index = input;
    var self = this;
    this.timeseries.infer_step(input, function(step) {
      self.step = step;
      self.context.step(step);
      // remake the data
      self.updateData(true);
    });
  }

  // Internal function: update a display parameter of the cubism charts
  updateParam(input, param_name) {
    // update this param
    if (param_name == "height") this.height = input;
    else if (param_name == "range-hi") this.range[1] = input;
    else if (param_name == "range-lo") this.range[0] = input;
    // if no valid update, just return
    else return;

    // redraw horizons
    var data = d3.select(this.target).selectAll('.horizon').data();
    delete_horizons(this);
    make_horizons(this, data);
  }

  // Internal function: start of the D3DataBuffer and collect data
  // remove_old: whether to delete the existing cubism plots
  updateData(remove_old) {
    // if no streams, don't do anything
    if (this.timeseries.config.streams.length == 0) {
      return;
    }

    if (remove_old === true) {
        delete_horizons(this);
    }

    // reset the poll
    if (!(this.buffer === undefined)) {
      this.buffer.stop();
    }

    // make a new buffer
    // to be on the safe side, get back to ~1000 data points
    var start = new Date(); 
    start.setSeconds(start.getSeconds() - this.step * this.max_data / 1000); // ms -> s
    this.cubism_on = false;

    var link = this.timeseries.data_link(this.stream_index, [this.metric]);

    // first build the poll
    var poll = new Data.D3DataPoll(new Data.D3DataLink(link), this.step, []);

    // get the data source
    //var source = new Data.D3DataSource(link, -1);

    // wrap with a buffer
    this.buffer = new Data.D3DataBuffer(poll, this.max_data, [this.startCubism.bind(this)]);
    this.buffer.start(start);
  }

  // Internal function: build the functions to link data between the D3DataBuffer and cubism
  dataLinks(buffers) {
    var ret = [];
    for (var j = 0; j < this.timeseries.config.instances.length; j++) {
      ret.push( build_data_link(j, buffers[j]) );
    }
    return ret;
  }

  // Internal function: run cubism for the first time
  startCubism(buffers) {
    if (!this.cubism_on) {
      this.cubism_metrics = add_metrics(this, this.dataLinks(buffers), true);
      this.cubism_on = true;
    }
  }

  // Start running cubism
  run() {
    this.buildContext(function(self) {
      self.updateData();
    });
  }

}

// add in metrics w/ a horizon chart to the provided target
function add_metrics(controller, data_links, use_instance_name) {
  // add new metrics
  var data = data_links.map(function(data_link, i) { 
    // use the instance name or the metric name
    if (use_instance_name) {
      var metric = controller.context.metric(data_link.bind(data_link), controller.timeseries.config.instances[i]);
    }
    else {
      var metric = controller.context.metric(data_link.bind(data_link), controller.timeseries.config.metric_list[i]);
    }
    //metric.on("change", function(start, stop) {});
    return metric;
  });
    return make_horizons(controller, data);
}

// BELOW: various helper functions used by the different Cubism*Controller classes

// make new horizon objects
function make_horizons(controller, data) {
  var horizon = controller.context.horizon();
  horizon = horizon.height(controller.height);
  if (controller.range !== undefined && controller.range.length != 0) { 
    horizon = horizon.extent(controller.range);
  }
  if (!(controller.format === undefined)) {
    horizon = horizon.format(controller.format);
  }
  var horizons = d3.select(controller.target).selectAll('.horizon')
      .data(data)
      .enter().insert("div", ".bottom")
      .attr("class", "horizon")
      .call(horizon);
  if (!(controller.onClick == undefined)) {
    horizons.on("click", controller.onClick.bind(controller));
  }
  return horizons;
}

// delete the horizons and the associated metrics
function delete_horizons(controller) {
  d3.select(controller.target).selectAll('.horizon')
      .call(controller.context.horizon().remove)
      .remove();
}

function create_cubism_context_with_step(target, step, callback) {
  // if we couldn't figure out what the step size should be, default to 1s
  // any step less than 1s is a mistake
  if (step < 1000) step = 1000; // units of ms
  var size = $(target).width();
  var context = cubism.context()
    //.serverDelay(timeseries.server_delay)
    .serverDelay(5000)
    .step(step)
    .size(size); 

  // delete old axes
  $(target + ' .axis').remove();
  
  // add time axes
  d3.select(target).selectAll(".axis")
    .data(["top", "bottom"])
    .enter().append("div")
    .attr("class", function(d) { return d + " axis"; })
    .each(function(d) {
     var axis = context.axis()
	.ticks(12)
	.orient(d);
	//.focusFormat(focus_format);
	d3.select(this).call(axis);
      });

  // delete old rule
  $(target + ' .rule').remove();
  
  d3.select(target).append("div")
  .attr("class", "rule")
  .call(context.rule());    
  
  callback(step, context);
}

function create_cubism_context(target, timeseries, callback) {
    // get what the step size should be 
    timeseries.infer_step(0, function(step) {
      create_cubism_context_with_step(target, step, callback);
    });
}

function build_data_link(ind, buffer) {
  return function(start, stop, step, callback) {
    // setup timestamps
    var tz_start = moment.tz(start, "US/Central");
    var tz_stop = moment.tz(stop, "US/Central");  
    var ts_start = tz_start.unix() * 1000;
    var ts_stop = tz_stop.unix() * 1000;
    var n_data = (ts_stop - ts_start) / step;
    
    // now get the data
    var ret = [];
    // special cases -- no data available
    if (buffer.size == 0 || 
      buffer.get_first()[0] > ts_stop ||
      buffer.get_last()[0] < ts_start) {
      for (var i = 0; i < n_data; i++) {
        ret.push(0);
      }
      return callback(null, ret);
    }
    
    // get data
    var last_index = 0;
    for (var i = 0; i < n_data; i ++) {
      var time = ts_start + i * step;
      while (true) {
        if (last_index == buffer.size) {
	  ret.push(0);
	  break;
        }
        var index = buffer.get(last_index)[0];
        // if the index is too small, continue
        if (index <= time) {
          last_index += 1;
          continue;
        }
        // if we're too small to have good data, just push zero
        if (last_index == 0) {
          ret.push(0);
          break;
        }
        // if there was a gap, continue
        if (time + step < index) {
            ret.push(0);
            break;
        }
        // otherwise, we can interpolate!
        ret.push(buffer.get(last_index)[1]);
        break;
      }
    }
    return callback(null, ret);
  };
}

