// TODO: use javascript imports
import * as Data from "./Data.js";
import * as DataLink from "./DataLink.js";
import * as Chart from "./charts.js";

// This class connects together a few differnet things for plotting time-series data

// This class takes in a "config" object which is generated by the Flask
// backend data_config API. This config object defines in an instance of
// time-series's with a list of fields.

// The class uses this configuration to spin up a list of time-series
// (instantiated by D3DataBuffer objects). Then, optionally, this list
// of time-series objects is connected to a histogram and/or scatter
// plot of the most recent data (as defined in charts.js)

// This class also manages responses to the webpage UI for modifying the
// layout of the plots. By default, there are no components connected.
// They can be turned on by the various xxxController functions
export class FieldData {
  // title: title of the plotly plots to be generated (histogram and/or
  //        scatter)
  // config: DataConfig object generated by the data_config backend and
  //         encoded as a JSON dictionary. Should correspond to a single
  //         instance of time-series's, with a list of fields
  // metric: The name of the metric in each time series.
  // stream: The name of the stream in each time-series.
  // stream_link: The base link for each time-series.
  constructor(title, config, metric, stream, stream_link) {
    this.config = config;
    this.title = title;
    this.buffer = null;
    this.metric = metric;
    this.stream = stream;
    this.stream_link = stream_link;
    this.metricParam();
    this.listeners = [];
    this.histograms = [];
    this.scatters = [];
  
    this.range = [];
    this.warning_range = [];
  }

  // "set" the configuration after constructing the class and calling
  // the various "xxxController" functions
  set() {
    this.metricParam();
    return this;
  }

  // Connect the metric name to a HTML form field 
  // id: the jQuery specified of the HTML form field
  metricController(id) {
    var self = this;
    $(id).change(function() { self.updateMetric(this.value); });
    return this;
  }

  // Connect the range lo/hi of each plot to a pair of HTML form fields
  // id_lo: the jQuery specified of the HTML form field controlling the
  //        range minimum value
  // id_hi: the jQuery specified of the HTML form field controlling the
  //        range maximum value
  // update_on_metric_change: (optional) set to true to update the 
  //                          HTML form field value to the default
  //                          metric configuration on metric name
  //                          change. True by default. If set to false,
  //                          then this class will never write to the
  //                          specified HTML form field.
  rangeController(id_lo, id_hi, update_on_metric_change) {
    var self = this;

    $(id_lo).keypress(function(e) {
      if (e.which == 13) {
        self.updateParam(this.value, "range-lo");
      }
    });
    $(id_hi).keypress(function(e) {
      if (e.which == 13) {
        self.updateParam(this.value, "range-hi");
      }
    });

    if (!(update_on_metric_change === false)) {
        this.range_lo_controller = id_lo;
        this.range_hi_controller = id_hi;
    }
    return this;
  }

  // Connect the lo/hi of the warning range on the Scatter plot object
  // to a pair of HTML form fields
  // id_lo: the jQuery specified of the HTML form field controlling the
  //        range minimum value
  // id_hi: the jQuery specified of the HTML form field controlling the
  //        range maximum value
  // update_on_metric_change: (optional) set to true to update the 
  //                          HTML form field value to the default
  //                          metric configuration on metric name
  //                          change. True by default. If set to false,
  //                          then this class will never write to the
  //                          specified HTML form field.
  warningrangeController(id_lo, id_hi, update_on_metric_change) {
    var self = this;
    $(id_lo).keypress(function(e) {
      if (e.which == 13) {
        self.updateParam(this.value, "warning-range-lo");
      }
    });
    $(id_hi).keypress(function(e) {
      if (e.which == 13) {
        self.updateParam(this.value, "warning-range-hi");
      }
    });

    if (!(update_on_metric_change === false)) {
        this.warning_range_lo_controller = id_lo;
        this.warning_range_hi_controller = id_hi;
    }
    return this;
  }

  // Get the number of data points to be plotted on the histogram and
  // scatter plots
  nData() {
    return this.config.fields.length;
  }

  // Internal function: starts up the D3DataBuffer objects to start
  // collecting data and plotting it in the histogram and/or scatter
  // chart
  updateBuffer() {
    if (this.buffer != null) this.buffer.stop();

    // TODO: currently we can either setup the D3DataBuffer with a Poll
    // (polling) or a Source (server side events). We should decide
    // which method to use

    // get the data link
    var link = new DataLink.MetricStreamLink($SCRIPT_ROOT + this.stream_link, this.stream, this.config.instance, this.config.fields, [this.metric]);
    // get the data poll
    //var poll = new Data.D3DataPoll(new Data.D3DataLink(link), this.step);

    // data source
    var source = new Data.D3DataSource(link, -1);

    // get the data buffer
    this.buffer = new Data.D3DataBuffer(source, 1, this.listeners); 
    // run with the most recent data
    var start = new Date();
    // go just a little back in time to get the first data
    start.setSeconds(start.getSeconds() - 2 * this.step / 1000); // ms -> s
    this.buffer.run(start);
  }

  // Call this function to tell the class to starting getting and
  // plotting data
  // 
  // Internally determines the step size of the time-series and then
  // calls updateBuffer()
  run() {
    // if no provided streams, don't run
    if (this.stream_link === undefined || this.stream === undefined) {
      alert("No data streams available for requested page");
      return;
    }

    // get the step size 
    var link = new DataLink.MetricStreamLink($SCRIPT_ROOT + this.stream_link, this.stream, this.config.instance, this.config.fields, [this.metric]);
    var self = this;
    d3.json(link.step_link(), function(data) {
      self.step = data.step; 
      if (self.step < 1000) self.step = 1000;
      self.updateBuffer();
    });
  }

  // Add a listener function to the D3DataBuffer object managed by this class
  addListener(f) {
    this.listeners.push(f);
  }

  // Internal function: get the layout for the Plotly Histogram managed
  // by this class
  layoutHistogram(yLabel) {
    var n_data = this.nData();
    var title = this.title + " " + this.metric;
    var ret = {
      title: titleize(title),
      xaxis: {
        title: this.metric,
        range: this.range
      },
      yaxis: {
        range: [0, n_data],
        title: yLabel
      }
    };
    return ret;
  }

  // Add a histogram plot to be shown with the data fetched by this
  // class
  // target: div-id of the div to contain this plot (excluding the '#')
  // yLabel: label of the y-axis on the fistogram to be shown 
  addHistogram(target, yLabel) {
    var n_data = this.nData();
    var layout = this.layoutHistogram(yLabel);
    var histogram =  new Chart.Histogram(n_data, target, layout);
    this.listeners.push(histogram.updateData.bind(histogram));
    this.histograms.push(histogram);
  }

  // Internal function: get the layout for the Plotly Scatter plot
  // managed by this class
  layoutScatter(xLabel) {
    var n_data = this.nData();
    var title = this.title + " " + this.metric;
    var ret = {
      title: titleize(title),
      xaxis: {
        title: xLabel
      },
      yaxis: {
        title: this.metric,
        range: this.range
      }
    };
    return ret;
  }

  // Add a scatter plot to be shown with the data fetched by this class
  // target: div-id of the div to contain this plot (excluding the '#')
  // title: the title of the plot to be drawn
  // xLabel: label of the x-axis on the fistogram to be shown 
  addScatter(target, title, xLabel) {
    var n_data = this.nData();
    var layout = this.layoutScatter(title, xLabel);
    if (this.warning_range.length != 0) {
      var scatter = new Chart.LineChart(n_data, target, layout, this.config.metric_config[this.metric].warning_range);
    }
    else {
      var scatter = new Chart.LineChart(n_data, target, layout);
    }
    this.listeners.push(scatter.updateData.bind(scatter));
    this.scatters.push(scatter);
  }

  // Internal function: set the configuration of the plots to be
  // displayed from the default configuration of the specified metric
  // (if such configuration exists)
  metricParam() {
    var metric_param = this.config.metric_config[this.metric];
    if (metric_param !== undefined && metric_param.range !== undefined) {
      this.range = metric_param.range;
    }
    else {
      this.range = [];
    }

    if (metric_param !== undefined && metric_param.warning_range !== undefined ){
      this.warning_range = metric_param.warning_range;
    }
    else {
      this.warning_range = [];
    }

    // set in range values
    if (!(this.range_lo_controller === undefined)) {
      if (this.range.length != 0) {
        $(this.range_lo_controller).val(this.range[0]);
      }
      else {
        $(this.range_lo_controller).val("");
      }
    }
    if (!(this.range_hi_controller === undefined)) {
      if (this.range.length != 0) {
        $(this.range_hi_controller).val(this.range[1]);
      }
      else {
         $(this.range_hi_controller).val("");
      }
    }

    if (!(this.warning_range_lo_controller === undefined)) {
      if (this.warning_range.length != 0) {
        $(this.warning_range_lo_controller).val(this.warning_range[0]);
      }
      else {
        $(this.warning_range_lo_controller).val("");
      }
    }
    if (!(this.warning_range_hi_controller === undefined)) {
      if (this.warning_range.length != 0) {
        $(this.warning_range_hi_controller).val(this.warning_range[1]);
      }
      else {
        $(this.warning_range_hi_controller).val("");
      }
    }
  }

  // Internal function: update a specified parameter using a specified
  // input
  updateParam(input, param_name) {
    // update this param
    if (param_name == "warning-range-hi") this.warning_range[1] = input;
    else if (param_name == "warning-range-lo") this.warning_range[0] = input;
    else if (param_name == "range-hi") this.range[1] = input;
    else if (param_name == "range-lo") this.range[0] = input;
    // if no valid update, just return
    else return;

    this.updatePlots();
  }

  // Internal function: upate the plots managed by this class to the
  // latest layout
  updatePlots() {
    var histo_update = { 
      "xaxis.range": this.range,
      "xaxis.title": this.metric,
      "title": titleize(this.title + " " + this.metric)
    };
    var scatter_update = {
      "yaxis.range": this.range,
      "yaxis.title": this.metric,
      "title": titleize(this.title + " " + this.metric)
    };
    // otherwise, update plots
    for (var i = 0; i < this.histograms.length; i++) {
      this.histograms[i].reLayout(histo_update);
    }
    for (var i = 0; i < this.scatters.length; i++) {
      this.scatters[i].reLayout(scatter_update);
      if (this.warning_range.length != 0) {
        this.scatters[i].updateRange(this.warning_range);
      }
    }
  }

  // Internal function: update the metric of each time-series to be
  // plotted
  updateMetric(input) {
    this.metric = input;
    this.metricParam();
    this.updatePoll();
    this.updatePlots();
  }

}

// Internal function: make a string into a title by capitalizing things
function titleize(str) {
    return str.replace(/_/g, ' ').replace(/\w\S*/g, function(txt){
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
}

