import * as DataLink from "./DataLink.js";
import * as TimeSeriesControllers from "./timeseries.js";
import * as GroupDataControllers from "./group_data.js";

// Class for handling configuration of groups of metrics and for
// changing the names of metric/stream/etc.
export class GroupConfigController {
  // config: DataConfig object generated by the redis backend and
  //         encoded as a JSON dictionary. Should contain the following
  //         fields:
  //           group: name of this group
  //           metric_list: list of all the metrics in this group
  //           instances: list of all the instances in this group
  //           streams: list of stream associated with this group
  //           stream_links: list of links to access each stream
  //           metric_config: configuration for display of each metric
  // href: (optional) function which will be passed the data_config group and
  //        instance corresponding to the clicked time-series and should 
  //        return a URL string that the user will navigate to. If
  //        nothing is passed, then nothing will happen when the user
  //        clicks on a strip chart
  constructor(config, href, metrics, instances, stream_index) {
    this.config = config;
    this.href = href;

    this.metrics = metrics;
    if (metrics !== undefined && metrics.length == 1) {
      this.metric_config = config.metric_config[metrics[0]];
    }
    else {
      this.metric_config = undefined;
    }
    this.instances = instances;
    this.stream_index = stream_index;

    this.controllers = [];

    // holder of 
    this.server_delay = 5000; // guess, for now
  }

  // Get the "DataLink" object to be used to query data for a list of
  // time-series
  // stream_index: The index into the streams/stream_links list for the
  //               stream corresponding to the DataLink we want
  // metric_list: The list of metric names to be queried in the
  //              time-series list
  // instance_list: The list of instances to be queried in the time-series
  //             list
  // NOTE: The final list of time-series will be a product of the
  // metric_list and the instance_list. I.e. if len(metric_list) = 3 and
  // len(instance_list) = 5 then there will be 15 total time-series
  // generated
  data_link(stream_index, metric_list, instance_list) {
    if (metric_list === undefined) {
      metric_list = this.config.metric_list;
    }
    if (instance_list === undefined) {
      var instances = this.config.instances;
    }
    else {
      var instances = [];
      for (var i = 0; i < instance_list.length; i++) {
        instances.push( this.config.instances[instance_list[i]] );
      }
    }
    return new DataLink.MetricStreamLink($SCRIPT_ROOT + "/" + this.config.stream_links[stream_index], this.config.streams[stream_index], 
        this.config.group, instances, metric_list, false);
  }

  // Get the time step value corresponding to a certain stream
  // stream_index: the index into the streams/stream_links list of the
  //               `stream to be inspected.
  // callback: Callback function to be called after the time-step value  
  //           is retreived. This function will be passed one argument: 
  //           the time step in milliseconds.
  infer_step(stream_index, callback) {
    if (this.config.stream_links.length == 0) return callback(0);
 
    var link = new DataLink.MetricStreamLink($SCRIPT_ROOT + this.config.stream_links[stream_index], this.config.streams[stream_index],
        this.config.group, this.config.instances, this.config.metric_list, false);

    return d3.json(link.step_link(), function(data) { callback(data.step); });
  }


  runAll() {
    if (this.config.streams.length == 0 || this.config.metric_list == 0) {
      alert("No data available for the requested group");
      return;
    }
    var self = this;
    var data_link = this.data_link(this.stream_index, this.metrics, this.instances);
    this.infer_step(0, function(step) {
      for (var i = 0; i < self.controllers.length; i++) {
        self.controllers[i].setStep(step);
        self.controllers[i].updateData(data_link);
      }
    });
  }

  // collect default parameters from metric
  default_param(metric) {
    return this.config.metric_config[metric];
  }

  // Internal function: hooks up the defined href to cubism for when the
  // user clicks on a strip chart 
  getLink(index) {
    if (!(this.href === undefined)) {
        return this.href(this.config.group, this.config.instances[index]);
    }
    return undefined;
  }

  // Connect the time-series metric name to a HTML form field 
  // id: the jQuery specified of the HTML form field
  metricController(id) {
    var self = this;
    $(id).change(function() { self.updateMetric([this.value]); });
    return this;
  }

  // Connect the time-series stream name to a HTML form field 
  // id: the jQuery specified of the HTML form field
  streamController(id) {
    var self = this;
    $(id).change(function() {self.updateStream(this.value);});
    return this;
  }

  getTitle(metric_name, instance_index) {
    var config = this.config.metric_config[metric_name];
    var instance = this.config.instances[instance_index];
    var title = this.config.metric_config[metric_name].title;
    if (title !== undefined) {
      title = title.replace("%(instance)s", instance).replace("%(group)s", this.config.group);    
    }
    return title;
  }

  // Internal function: change the metric name being shown in the cubism charts
  updateMetric(metrics) {
    this.metrics = metrics;
    if (metrics !== undefined && metrics.length == 1) {
      this.metric_config = this.config.metric_config[metrics[0]];
    }
    else {
      this.metric_config = undefined;
    }

    var data_link = this.data_link(this.stream_index, this.metrics, this.instances);
     
    for (var i = 0; i < this.controllers.length; i++) {
      this.controllers[i].updateMetricConfig(this.metric_config);
      this.controllers[i].updateData(data_link, true);
    }
  } 

  // Internal function: change the stream name of the time-series
  // plotted in cubism 
  updateStream(input) {
    this.stream_index = input;
    var self = this;
    this.infer_step(input, function(step) {
      var data_link = self.data_link(self.stream_index, self.metrics, self.instances);
      for (var i = 0; i < self.controllers.length; i++) {
         self.controllers[i].updateStep(step);
         self.controllers[i].updateData(data_link, true);
      }
    });
  }

  // add a cubism controller 
  addCubismController(target, height) {
    var data_link = this.data_link(this.stream_index, this.metrics, this.instances);
    var controller = new TimeSeriesControllers.CubismController(target, data_link, this.metric_config, height);
    if (this.href !== undefined ) {
      controller.setLinkFunction(this.getLink.bind(this));
      controller.setGetTitle(this.getTitle.bind(this));
    }
    this.controllers.push(controller);
    return controller;
  }

  // add a plotly controller
  addPlotlyController(target) {
    var data_link = this.data_link(this.stream_index, this.metrics, this.instances);
    var controller = new TimeSeriesControllers.PlotlyController(target, data_link, this.metric_config);
    this.controllers.push(controller);
    return controller;
  }

  // add a group data controller
  addGroupDataScatterController(target, title) {
    var data_link = this.data_link(this.stream_index, this.metrics, this.instances);
    var controller = new GroupDataControllers.GroupDataScatterController(target, data_link, this.metric_config, title, this.config.group);
    this.controllers.push(controller);
    return controller;
  }

  // add a group data controller
  addGroupDataHistoController(target, title) {
    var data_link = this.data_link(this.stream_index, this.metrics, this.instances);
    var controller = new GroupDataControllers.GroupDataHistoController(target, data_link, this.metric_config, title, this.config.group);
    this.controllers.push(controller);
    return controller;
  }
  // add a group data controller
  addGroupDataScatterController(target, title) {
    var data_link = this.data_link(this.stream_index, this.metrics, this.instances);
    var controller = new GroupDataControllers.GroupDataScatterController(target, data_link, this.metric_config, title, this.config.group);
    this.controllers.push(controller);
    return controller;
  }
}

